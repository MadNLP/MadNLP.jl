<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>KKT systems · MadNLP.jl</title><meta name="title" content="KKT systems · MadNLP.jl"/><meta property="og:title" content="KKT systems · MadNLP.jl"/><meta property="twitter:title" content="KKT systems · MadNLP.jl"/><meta name="description" content="Documentation for MadNLP.jl."/><meta property="og:description" content="Documentation for MadNLP.jl."/><meta property="twitter:description" content="Documentation for MadNLP.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="MadNLP.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MadNLP.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../quickstart/">Quickstart</a></li><li><a class="tocitem" href="../../options/">Options</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/multiprecision/">Multi-precision</a></li><li><a class="tocitem" href="../../tutorials/warmstart/">Warm-start</a></li><li><a class="tocitem" href="../../tutorials/lbfgs/">LBFGS</a></li><li><a class="tocitem" href="../../tutorials/kktsystem/">Custom KKT system</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../solver/">IPM solver</a></li><li class="is-active"><a class="tocitem" href>KKT systems</a><ul class="internal"><li><a class="tocitem" href="#A-brief-look-at-the-math"><span>A brief look at the math</span></a></li><li><a class="tocitem" href="#Assembling-a-KKT-system,-step-by-step"><span>Assembling a KKT system, step by step</span></a></li><li><a class="tocitem" href="#Solution-of-the-KKT-system"><span>Solution of the KKT system</span></a></li></ul></li><li><a class="tocitem" href="../linear_solvers/">Linear Solvers</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../lib/ipm/">IPM solver</a></li><li><a class="tocitem" href="../../lib/callbacks/">Callback wrappers</a></li><li><a class="tocitem" href="../../lib/kkt/">KKT systems</a></li><li><a class="tocitem" href="../../lib/linear_solvers/">Linear Solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>KKT systems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>KKT systems</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MadNLP/MadNLP.jl/blob/master/docs/src/man/kkt.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="KKT-systems"><a class="docs-heading-anchor" href="#KKT-systems">KKT systems</a><a id="KKT-systems-1"></a><a class="docs-heading-anchor-permalink" href="#KKT-systems" title="Permalink"></a></h1><p>KKT systems are linear system with a special KKT structure. MadNLP uses a special structure <a href="../../lib/kkt/#AbstractKKTSystem"><code>AbstractKKTSystem</code></a> to represent internally the KKT system. The <a href="../../lib/kkt/#AbstractKKTSystem"><code>AbstractKKTSystem</code></a> fulfills two goals:</p><ol><li>Store the values of the Hessian of the Lagrangian and of the Jacobian.</li><li>Assemble the corresponding KKT matrix <span>$K$</span>.</li></ol><h2 id="A-brief-look-at-the-math"><a class="docs-heading-anchor" href="#A-brief-look-at-the-math">A brief look at the math</a><a id="A-brief-look-at-the-math-1"></a><a class="docs-heading-anchor-permalink" href="#A-brief-look-at-the-math" title="Permalink"></a></h2><p>We recall that at each iteration the interior-point algorithm aims at solving the following relaxed KKT equations (<span>$\mu$</span> playing the role of a homotopy parameter) with a Newton method:</p><p class="math-container">\[F_\mu(x, s, y, v, w) = 0\]</p><p>with</p><p class="math-container">\[F_\mu(x, s, y, v, w) =
\left\{
\begin{aligned}
    &amp; \nabla f(x) + A^\top y + \nu + w &amp; (F_1) \\
    &amp; - y - w  &amp; (F_2) \\
    &amp; g(x) - s &amp;  (F_3) \\
    &amp; X v - \mu e_n &amp; (F_4) \\
    &amp; S w - \mu e_m &amp; (F_5)
\end{aligned}
\right.\]</p><p>The Newton step associated to the KKT equations writes</p><p class="math-container">\[\overline{
\begin{pmatrix}
 W &amp; 0 &amp; A^\top &amp; - I &amp; 0 \\
 0 &amp; 0 &amp; -I &amp; 0 &amp; -I \\
 A &amp; -I &amp; 0&amp; 0 &amp; 0 \\
 V &amp; 0 &amp; 0 &amp; X &amp; 0 \\
 0 &amp; W &amp; 0 &amp; 0 &amp; S
\end{pmatrix}}^{K_{3}}
\begin{pmatrix}
    \Delta x \\
    \Delta s \\
    \Delta y \\
    \Delta v \\
    \Delta w
\end{pmatrix}
= -
\begin{pmatrix}
    F_1 \\ F_2 \\ F_3 \\ F_4 \\ F_5
\end{pmatrix}\]</p><p>The matrix <span>$K_3$</span> is unsymmetric, but we can obtain an equivalent symmetric system by eliminating the two last rows:</p><p class="math-container">\[\overline{
\begin{pmatrix}
 W + \Sigma_x &amp; 0 &amp; A^\top \\
 0 &amp; \Sigma_s &amp; -I \\
 A &amp; -I &amp; 0
\end{pmatrix}}^{K_{2}}
\begin{pmatrix}
    \Delta x \\
    \Delta s \\
    \Delta y
\end{pmatrix}
= -
\begin{pmatrix}
    F_1 + X^{-1} F_4 \\ F_2 + S^{-1} F_5 \\ F_3
\end{pmatrix}\]</p><p>with <span>$\Sigma_x = X^{-1} v$</span> and <span>$\Sigma_s = S^{-1} w$</span>. The matrix <span>$K_2$</span>, symmetric, has a structure more favorable for a direct linear solver.</p><p>In MadNLP, the matrix <span>$K_3$</span> is encoded as an <a href="../../lib/kkt/#MadNLP.AbstractUnreducedKKTSystem"><code>AbstractUnreducedKKTSystem</code></a> and the matrix <span>$K_2$</span> is encoded as an <a href="../../lib/kkt/#MadNLP.AbstractReducedKKTSystem"><code>AbstractReducedKKTSystem</code></a>.</p><h2 id="Assembling-a-KKT-system,-step-by-step"><a class="docs-heading-anchor" href="#Assembling-a-KKT-system,-step-by-step">Assembling a KKT system, step by step</a><a id="Assembling-a-KKT-system,-step-by-step-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-a-KKT-system,-step-by-step" title="Permalink"></a></h2><p>We note that both <span>$K_3$</span> and <span>$K_2$</span> depend on the Hessian of the Lagrangian <span>$W$</span>, the Jacobian <span>$A$</span> and the diagonal matrices <span>$\Sigma_x = X^{1}V$</span> and <span>$\Sigma_s = S^{-1}W$</span>. Hence, we have to update the KKT system at each iteration of the interior-point algorithm.</p><p>By default, MadNLP stores the KKT system as a <a href="../../lib/kkt/#MadNLP.SparseKKTSystem"><code>SparseKKTSystem</code></a>. The KKT system takes as input a <a href="../../lib/callbacks/#MadNLP.SparseCallback"><code>SparseCallback</code></a> wrapping a given <code>NLPModel</code> <code>nlp</code>. We instantiate the callback <code>cb</code> with the function <a href="../../lib/callbacks/#MadNLP.create_callback"><code>create_callback</code></a>:</p><pre><code class="language-julia hljs">cb = MadNLP.create_callback(
    MadNLP.SparseCallback,
    nlp,
)
ind_cons = MadNLP.get_index_constraints(nlp)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(ind_eq = Int64[], ind_ineq = [1, 2], ind_fixed = Int64[], ind_lb = [3, 4], ind_ub = [1], ind_llb = Int64[], ind_uub = [1])</code></pre><h3 id="Initializing-a-KKT-system"><a class="docs-heading-anchor" href="#Initializing-a-KKT-system">Initializing a KKT system</a><a id="Initializing-a-KKT-system-1"></a><a class="docs-heading-anchor-permalink" href="#Initializing-a-KKT-system" title="Permalink"></a></h3><p>The size of the KKT system depends directly on the problem&#39;s characteristics (number of variables, number of of equality and inequality constraints). A <a href="../../lib/kkt/#MadNLP.SparseKKTSystem"><code>SparseKKTSystem</code></a> stores the Hessian and the Jacobian in sparse (COO) format. The KKT matrix can be factorized using either a dense or a sparse linear solvers. Here we use the solver provided in Lapack:</p><pre><code class="language-julia hljs">linear_solver = LapackCPUSolver</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LapackCPUSolver</code></pre><p>We can instantiate a <code>SparseKKTSystem</code> using the function <a href="../../lib/kkt/#MadNLP.create_kkt_system"><code>create_kkt_system</code></a>:</p><pre><code class="language-julia hljs">kkt = MadNLP.create_kkt_system(
    MadNLP.SparseKKTSystem,
    cb,
    ind_cons,
    linear_solver,
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MadNLP.SparseKKTSystem{Float64, Vector{Float64}, SparseArrays.SparseMatrixCSC{Float64, Int32}, MadNLP.ExactHessian{Float64, Vector{Float64}}, LapackCPUSolver{Float64, SparseArrays.SparseMatrixCSC{Float64, Int32}}, Vector{Int64}, Vector{Int32}}([0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0], MadNLP.ExactHessian{Float64, Vector{Float64}}(), [8.0e-323, 6.93858654181453e-310, 6.93858654182875e-310, 6.9385753996461e-310], [0.0, 0.0, 0.0, 0.0], [0.0, 0.0], [6.93857810139466e-310, 6.9385867064032e-310], [1.0e-323], [6.9385753996461e-310, 6.9385845261081e-310], [6.9385849647317e-310], [0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0], sparse(Int32[1, 2, 5, 6, 2, 5, 6, 3, 5, 4, 6, 5, 6], Int32[1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0], 6, 6), [1, 5, 8, 10, 1, 2, 5, 3, 6, 4, 7, 9, 11, 12, 13], [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0], sparse(Int32[1, 2, 2], Int32[1, 1, 2], [1.0, 2.0, 3.0], 4, 4), [1, 2, 3], [0.0 0.0 0.0 0.0; 0.0 0.0 0.0 0.0], sparse(Int32[1, 2, 1, 2, 1, 2], Int32[1, 1, 2, 2, 3, 4], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0], 2, 4), [1, 3, 2, 4, 5, 6], LapackCPUSolver{Float64, SparseArrays.SparseMatrixCSC{Float64, Int32}}(sparse(Int32[1, 2, 5, 6, 2, 5, 6, 3, 5, 4, 6, 5, 6], Int32[1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6], [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0], 6, 6), [6.938578981241e-310 6.9385789816655e-310 … 0.0 6.93857898124415e-310; 6.938578981241e-310 6.93857541420323e-310 … 0.0 6.9385789812505e-310; … ; 6.9385762547915e-310 6.9385443332884e-310 … 6.93857898124415e-310 6.93857898166865e-310; 6.93857625479783e-310 6.93858411859644e-310 … 6.938578981241e-310 6.93857898166865e-310], 6, Float64[], Float64[], Float64[], [384.0, 0.0, 0.0, 7.22497126907856e-310, 0.0, 0.0, 8.27578358476e-313, 0.0, 0.0, 0.0  …  3.16e-322, 3.56e-322, 3.95e-322, 4.35e-322, 4.74e-322, 5.14e-322, 5.53e-322, 5.93e-322, 6.3e-322, 6.7e-322], 384, [140438329906720], -1, Base.RefValue{Int64}(0), [140438541639544, 3, 563204, 3, 3, 140438517726704], MadNLP.LapackOptions(MadNLP.BUNCHKAUFMAN), MadNLP.MadNLPLogger(MadNLP.INFO, MadNLP.INFO, nothing)), [1, 2], [3, 4], [1])</code></pre><p>Once the KKT system built, one has to initialize it to use it inside the interior-point algorithm:</p><pre><code class="language-julia hljs">MadNLP.initialize!(kkt);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>The user can query the KKT matrix inside <code>kkt</code>, simply as</p><pre><code class="language-julia hljs">kkt_matrix = MadNLP.get_kkt(kkt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×6 SparseArrays.SparseMatrixCSC{Float64, Int32} with 13 stored entries:
 1.0   ⋅    ⋅     ⋅     ⋅     ⋅ 
 2.0  5.0   ⋅     ⋅     ⋅     ⋅ 
  ⋅    ⋅   8.0    ⋅     ⋅     ⋅ 
  ⋅    ⋅    ⋅   10.0    ⋅     ⋅ 
 3.0  6.0  9.0    ⋅   12.0    ⋅ 
 4.0  7.0   ⋅   11.0    ⋅   13.0</code></pre><p>This returns a reference to the KKT matrix stores internally inside <code>kkt</code>. Each time the matrix is assembled inside <code>kkt</code>, <code>kkt_matrix</code> is updated automatically.</p><h3 id="Updating-a-KKT-system"><a class="docs-heading-anchor" href="#Updating-a-KKT-system">Updating a KKT system</a><a id="Updating-a-KKT-system-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-a-KKT-system" title="Permalink"></a></h3><p>We suppose now we want to refresh the values stored in the KKT system.</p><h4 id="Updating-the-values-of-the-Hessian"><a class="docs-heading-anchor" href="#Updating-the-values-of-the-Hessian">Updating the values of the Hessian</a><a id="Updating-the-values-of-the-Hessian-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-the-values-of-the-Hessian" title="Permalink"></a></h4><p>The Hessian part of the KKT system can be queried as</p><pre><code class="language-julia hljs">hess_values = MadNLP.get_hessian(kkt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
 0.0
 0.0
 0.0</code></pre><p>For a <code>SparseKKTSystem</code>, <code>hess_values</code> is a <code>Vector{Float64}</code> storing the nonzero values of the Hessian. Then, one can update the vector <code>hess_values</code> by using NLPModels.jl:</p><pre><code class="language-julia hljs">n = NLPModels.get_nvar(nlp)
m = NLPModels.get_ncon(nlp)
x = NLPModels.get_x0(nlp) # primal variables
l = zeros(m) # dual variables

NLPModels.hess_coord!(nlp, x, l, hess_values)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3-element Vector{Float64}:
   2.0
   0.0
 200.0</code></pre><p>Eventually, a post-processing step is applied to refresh all the values internally:</p><pre><code class="language-julia hljs">MadNLP.compress_hessian!(kkt)</code></pre><div class="admonition is-info" id="Note-6787d7c3b60038a4"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-6787d7c3b60038a4" title="Permalink"></a></header><div class="admonition-body"><p>By default, the function <a href="../../lib/kkt/#MadNLP.compress_hessian!"><code>compress_hessian!</code></a> does nothing. But it can be required for very specific use-case, for instance building internally a Schur complement matrix.</p></div></div><h4 id="Updating-the-values-of-the-Jacobian"><a class="docs-heading-anchor" href="#Updating-the-values-of-the-Jacobian">Updating the values of the Jacobian</a><a id="Updating-the-values-of-the-Jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-the-values-of-the-Jacobian" title="Permalink"></a></h4><p>We proceed exaclty the same way to update the values in the Jacobian. One queries the Jacobian values in the KKT system as</p><pre><code class="language-julia hljs">jac_values = MadNLP.get_jacobian(kkt)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0</code></pre><p>We can refresh the values with NLPModels as</p><pre><code class="language-julia hljs">NLPModels.jac_coord!(nlp, x, jac_values)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 0.0
 0.0
 1.0
 0.0</code></pre><p>And then applies a post-processing step as</p><pre><code class="language-julia hljs">MadNLP.compress_jacobian!(kkt)</code></pre><h4 id="Updating-the-values-of-the-diagonal-matrices"><a class="docs-heading-anchor" href="#Updating-the-values-of-the-diagonal-matrices">Updating the values of the diagonal matrices</a><a id="Updating-the-values-of-the-diagonal-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Updating-the-values-of-the-diagonal-matrices" title="Permalink"></a></h4><p>Once the Hessian and the Jacobian updated, the algorithm can apply primal and dual regularization terms on the diagonal of the KKT system, to improve the numerical behavior in the linear solver. This operation is implemented inside the <a href="../../lib/kkt/#MadNLP.regularize_diagonal!"><code>regularize_diagonal!</code></a> function:</p><pre><code class="language-julia hljs">pr_value = 1.0
du_value = 0.0

MadNLP.regularize_diagonal!(kkt, pr_value, du_value)</code></pre><h3 id="Assembling-the-KKT-matrix"><a class="docs-heading-anchor" href="#Assembling-the-KKT-matrix">Assembling the KKT matrix</a><a id="Assembling-the-KKT-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Assembling-the-KKT-matrix" title="Permalink"></a></h3><p>Once the values updated, one can assemble the resulting KKT matrix. This translates to</p><pre><code class="language-julia hljs">MadNLP.build_kkt!(kkt)</code></pre><p>By doing so, the values stored inside <code>kkt</code> will be transferred to the KKT matrix <code>kkt_matrix</code> (as returned by the function <a href="../../lib/kkt/#MadNLP.get_kkt"><code>get_kkt</code></a>):</p><pre><code class="language-julia hljs">kkt_matrix</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×6 SparseArrays.SparseMatrixCSC{Float64, Int32} with 13 stored entries:
 4.0     ⋅     ⋅     ⋅    ⋅    ⋅ 
 0.0  202.0    ⋅     ⋅    ⋅    ⋅ 
  ⋅      ⋅    2.0    ⋅    ⋅    ⋅ 
  ⋅      ⋅     ⋅    2.0   ⋅    ⋅ 
 0.0    0.0  -1.0    ⋅   0.0   ⋅ 
 1.0    0.0    ⋅   -1.0   ⋅   0.0</code></pre><p>Internally, a <a href="../../lib/kkt/#MadNLP.SparseKKTSystem"><code>SparseKKTSystem</code></a> stores the KKT system in a sparse COO format. When <a href="../../lib/kkt/#MadNLP.build_kkt!"><code>build_kkt!</code></a> is called, the sparse COO matrix is transferred to <code>SparseMatrixCSC</code> if the linear solver is sparse, or alternatively to a <code>Matrix</code> if the linear solver is dense.</p><div class="admonition is-info" id="Note-a499eecf98f5bdcb"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a499eecf98f5bdcb" title="Permalink"></a></header><div class="admonition-body"><p>The KKT system stores only the lower-triangular part of the KKT system, as it is symmetric.</p></div></div><h2 id="Solution-of-the-KKT-system"><a class="docs-heading-anchor" href="#Solution-of-the-KKT-system">Solution of the KKT system</a><a id="Solution-of-the-KKT-system-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-of-the-KKT-system" title="Permalink"></a></h2><p>Now the KKT system is assembled in a matrix <span>$K$</span> (here stored in <code>kkt_matrix</code>), we want to solve a linear system <span>$K x = b$</span>, for instance to evaluate the next descent direction. To do so, we use the linear solver stored internally inside <code>kkt</code> (here an instance of <code>LapackCPUSolver</code>).</p><p>We start by factorizing the KKT matrix <span>$K$</span>:</p><pre><code class="language-julia hljs">MadNLP.factorize!(kkt.linear_solver)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LapackCPUSolver{Float64, SparseArrays.SparseMatrixCSC{Float64, Int32}}(sparse(Int32[1, 2, 5, 6, 2, 5, 6, 3, 5, 4, 6, 5, 6], Int32[1, 1, 1, 1, 2, 2, 2, 3, 3, 4, 4, 5, 6], [4.0, 0.0, 0.0, 1.0, 202.0, 0.0, 0.0, 2.0, -1.0, 2.0, -1.0, 0.0, 0.0], 6, 6), [4.0 0.0 … 0.0 0.0; 0.0 202.0 … 0.0 0.0; … ; 0.0 0.0 … -0.5 0.0; 0.25 0.0 … -0.0 -0.75], 6, Float64[], Float64[], Float64[], [384.0, 0.0, 0.0, 7.22497126907856e-310, 0.0, 0.0, 8.27578358476e-313, 0.0, 0.0, 0.0  …  3.16e-322, 3.56e-322, 3.95e-322, 4.35e-322, 4.74e-322, 5.14e-322, 5.53e-322, 5.93e-322, 6.3e-322, 6.7e-322], 384, [140438329906720], -1, Base.RefValue{Int64}(0), [1, 2, 3, 4, 5, 6], MadNLP.LapackOptions(MadNLP.BUNCHKAUFMAN), MadNLP.MadNLPLogger(MadNLP.INFO, MadNLP.INFO, nothing))</code></pre><p>By default, MadNLP uses a LBL factorization to decompose the symmetric indefinite KKT matrix.</p><p>Once the KKT matrix has been factorized, we can compute the solution of the linear system with a backsolve. The function takes as input a <a href="../../lib/kkt/#AbstractKKTVector"><code>AbstractKKTVector</code></a>, an object used to do algebraic manipulation with a <a href="../../lib/kkt/#AbstractKKTSystem"><code>AbstractKKTSystem</code></a>. We start by instantiating two <a href="../../lib/kkt/#MadNLP.UnreducedKKTVector"><code>UnreducedKKTVector</code></a> (encoding respectively the right-hand-side and the solution):</p><pre><code class="language-julia hljs">b = MadNLP.UnreducedKKTVector(kkt)
fill!(MadNLP.full(b), 1.0)
x = copy(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">MadNLP.UnreducedKKTVector{Float64, Vector{Float64}, Vector{Int64}}([1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0, 1.0, 1.0], [1.0, 1.0, 1.0, 1.0], [1.0, 1.0], [1.0], [1.0, 1.0], [1.0, 1.0], [1.0])</code></pre><p>The right-hand-side encodes a vector of 1:</p><pre><code class="language-julia hljs">MadNLP.full(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0</code></pre><p>We solve the system <span>$K x = b$</span> using the <a href="../../lib/linear_solvers/#SolverCore.solve!"><code>solve!</code></a> function:</p><pre><code class="language-julia hljs">MadNLP.solve!(kkt, x)
MadNLP.full(x)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Float64}:
  0.3333333333333333
  0.0049504950495049506
 -1.0
 -0.6666666666666666
 -2.0
 -1.3333333333333333
 -1.0
 -1.0
  1.0</code></pre><p>We verify that the solution is correct by multiplying it on the left with the KKT system, using <code>mul!</code>:</p><pre><code class="language-julia hljs">mul!(b, kkt, x) # overwrite b!
MadNLP.full(b)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">9-element Vector{Float64}:
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0
 1.0</code></pre><p>We recover a vector filled with <code>1</code>, which was the initial right-hand-side.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solver/">« IPM solver</a><a class="docs-footer-nextpage" href="../linear_solvers/">Linear Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 25 September 2025 19:02">Thursday 25 September 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
